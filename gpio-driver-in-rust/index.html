

<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

      <title></title>

      

      
          <link rel="stylesheet" href="http://mysterious.computer/site.css">
      

      
      
    </head>

    <body class="hack dark main container">
        

<article itemscope itemtype="http://schema.org/BlogPosting">
    <header>
        <h1 itemprop="headline">hardware peripherals and typestate analysis</h1>
        <span class="muted">
    <svg style="margin-bottom:-3px" class="i-clock" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <circle cx="16" cy="16" r="14"/>
        <path d="M16 8 L16 16 20 20"/>
    </svg>
    <span>8 minute read</span>
    <svg style="margin-bottom: -3px" class="i-edit" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <path d="M30 7 L25 2 5 22 3 29 10 27 Z M21 6 L26 11 Z M5 22 L10 27 Z"/>
    </svg>

    Published: 2019-01-02
</span>
    </header>
    <div itemprop="articleBody">
      <p>In this post we'll walk though the code that makes up the GPIO driver in subphase C of
<a href="https://web.stanford.edu/class/cs140e/assignments/1-shell/#subphase-c-gpio">assignment one</a> of Stanford's cs140e course, where we see hardware peripherals modeled as a
kind of <a href="https://en.wikipedia.org/wiki/Finite-state_machine">finite state machine</a>, with the type system being used to enforce certain static guarantees
that our code itself doesn't cause the hardware to go into some nonsensical or &quot;<a href="http://www.merkur-online.de/bilder/2009/04/21/216591/1389401738-toaster-explosion-feuer-2409.jpg">invalid state</a>&quot;.
This is a combination exploration of type systems and their use when developing drivers for the
peripherals of embedded devices.</p>
<p>To get there we should explore each of the ideas that help us understand what this all means from the beginning
and then zoom into our final goal.</p>
<h2 id="types">Types</h2>
<p>Like many concepts in computer programming, &quot;types&quot; are an older mathematical concept that
finds it's existence reified in the type systems of modern day programming languages.
In a nutshell, the word &quot;type&quot; has similar meaning to when one says &quot;this type of thing or another&quot;,
denoting that two, maybe similar, things have different properties. For our case these  <em>types</em> are given
to the <em>terms</em> in the language we are writing in.</p>
<p>In the language of arithmetic we can say <code>41 + 1</code>, or <code>42</code>, or <code>21 * 2</code> are all valid terms
with their type as natural numbers, abbreviated as <code>nat</code> - maybe written with a colon to denote
the type like <code>42: nat</code><sup class="footnote-reference"><a href="#2">1</a></sup>. Whereas
a term like <code>1 / 2</code> is an invalid expression for <code>nat</code> types but a valid rational number, which
is another type.</p>
<p>For a natural language, like English, we have terms with types whose composition is defined
by the grammar. We can say that <code>cold</code> is of the adjective type and <code>beer</code> is of the <code>noun</code>
type with our grammar saying we must put adjectives <em>before</em> the nouns, thus &quot;cold beer&quot; is
a valid expression while &quot;beer cold&quot; is a nonsensical one.</p>
<p>The mathematical notion of the &quot;type&quot; grew out of some apparent inconsistencies in the foundations
of mathematics. Bertrand Russel wrote of the &quot;theories of type&quot; back in 1802 as a way to patch a version of
<a href="https://en.wikipedia.org/wiki/Naive_set_theory">naive set theory</a> that was afflicted with <a href="https://en.wikipedia.org/wiki/Russell%27s_paradox">Russel's paradox</a>. The details of this are beyond
the scope of this article, but we'll address the more common usage of what we mean by a &quot;type theory&quot; when we
explore Alonzo Church's simply typed lambda calculus in <a href="https://mysterious.computer/simply-type-lambda-calculus">another post</a></p>
<p>The theory of types as created by Russel was a new logical language different from set theory
where concepts like &quot;and&quot; and &quot;or&quot; and &quot;maybe&quot;, found in the predicate logic set theory was
built upon, can be encoded into the types of the type system itself. See the wikipedia post on
<a href="https://en.wikipedia.org/wiki/Typestate_analysis">type theory</a> for how concepts in set theory find their counterpart in the theory of types.</p>
<p>It should suffice to say that when we are giving a <em>type</em> to a term, variable, or object we are determining
the set of things we can <em>do</em> to that object and that a language with a type system can check statements
in the language for their <em>type correctness</em> to enforce that operations applied to operands are of the correct type.
This is a powerful concept that helps us create large systems that are easier to reason about, in which the programs
when compiled and type checked are themselves sort of proofs of their correctness.</p>
<p>Cool. So, what are some sorts of things that can be encoded in a type system?</p>
<h2 id="type-states">Type States</h2>
<p>There are many things we can encode into a type system, here we're going to jump beyond numbers, pairs, booleans,
sum and product and types, and the like, and talk about something a little more arcane: type states.</p>
<p>So, what exactly is a  <em>type state</em>? Informally said, they are, as you might think, the idea that we can ascribe
a given set of states to some type. Where we say that some object with some type is always in one of the type states
associated with that type. To move from one type state to another we perform some operation thats <em>allowable</em> on that
type in the given type state that it's in. These operations<sup class="footnote-reference"><a href="#3">2</a></sup>, for a type with type states, when done one after the
other effectively act a series of <em>state transitions</em> (coercions) between states (types) and thus form a kind of finite state machine,
allowing us to keep track of the state that some statefully typed object is in.</p>
<p>In a large sense, <em>type states</em> also allow us to keep track of the <em>order</em> in which certain operations are made on an object.</p>
<p>To illustrate why this is a useful idea, let's make this more concrete with a practical example:</p>
<p>Say we have a <code>File</code> type, with three states: &quot;uninitialized&quot;, &quot;opened&quot; and &quot;closed&quot;. The state machine could be drawn something like:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">.---------------. open  .--------. close  .--------.
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">| uninitialized | ----&gt; | opened | -----&gt; | closed |
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">&#39;---------------&#39;       &#39;--------&#39;        &#39;--------&#39;
</span><span style="color:#c0c5ce;">                                  </span><span style="color:#c0c5ce;">^    |
</span><span style="color:#c0c5ce;">                                  </span><span style="color:#c0c5ce;">`----&#39;
</span><span style="color:#c0c5ce;">                                 </span><span style="color:#c0c5ce;">seek/read
</span></pre>
<p>A <code>File</code> can't be read unless it has been opened, we also can't seek to a part of the
file unless it is open, nor can we close an unopened file. Though, once the file is
open we can do those things, and then close when finished. To borrow from David Teller's
<a href="https://yoric.github.io/post/rust-typestate/">example</a>, let's show what this would look like in Rust:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">read_file</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">path</span><span style="color:#c0c5ce;">: &amp;Path) -&gt; String {
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> file = File::open(path);
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// opening the file _could_ fail
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">file.</span><span style="color:#96b5b4;">open</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// invalid read() if file failed to open
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> data = file.</span><span style="color:#96b5b4;">read</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">file.</span><span style="color:#96b5b4;">close</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">file.</span><span style="color:#96b5b4;">seek</span><span style="color:#c0c5ce;">(Seek::Start); </span><span style="color:#65737e;">// ERROR! Already closed.
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">data
</span><span style="color:#c0c5ce;">}
</span></pre><h2 id="typed-move-semantics">Typed move semantics</h2>
<p>How can we ensure that this kind of behavior is caught by the Rust compiler? Luckily for us
we can exploit Rust's <a href="https://en.wikipedia.org/wiki/Substructural_type_system#Affine_type_systems">affline type system</a> to leverage the use of it's special <em>move semantics</em>.
If you haven't already read the <a href="https://doc.rust-lang.org/book/second-edition/ch04-00-understanding-ownership.html">Book</a>, at least as much of it s.t. you understand
the basic ideas behind ownership and borrowing, and what the <code>Drop</code> trait is - now would be a good
time to do so.</p>
<p>Here's the implementation of our <code>File</code>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">impl </span><span style="color:#c0c5ce;">File {
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// NOTE: Here we&#39;re using the venerable `Result` type which gives the postfix &quot;?&quot; operator
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">//       that allows us to propagate errors if, say, any operations on the file fail.
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">open</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">path</span><span style="color:#c0c5ce;">: &amp;Path) -&gt; Result&lt;File, Error&gt; {
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// ...
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// NOTE: Here `self` is &quot;moved&quot; into `close()`, by being passed by value and not
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">//       by reference, consuming the file and effectively making any operations
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">//       on `self` after this call to `close()` invalid.
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">close</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">) -&gt; Result&lt;(), Error&gt; {
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// ...
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// NOTE: &amp;mut self, is a mutable reference and doesn&#39;t actually consume the file,
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">//       making operations on self after reading, valid.
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">read</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">) -&gt; Result&lt;String, Error&gt; {
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// ...
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">seek</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">) -&gt; Result&lt;(), Error&gt; {
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;">// ...
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>As you can see, depending on how we use references and Rust's move semantics by passing <code>self</code>,
<code>&amp;self</code>, or <code>&amp;mut self</code> to the various <code>File</code> operations we are trivially informing Rust of
a <code>File</code>'s type states and they can be enforced at compile-time.</p>
<p>Let's go about implementing <code>Drop</code> for our <code>File</code> before re-evaluating the type checker's reaction to <code>read_file()</code>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">impl </span><span style="color:#c0c5ce;">Drop </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">File {
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// NOTE: The Drop trait is basically like a &quot;destructor&quot; that can be used to
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">//       automatically close the file when it falls out of scope.
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">drop</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">) {
</span><span style="color:#c0c5ce;">        </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.</span><span style="color:#96b5b4;">close</span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>Now here's the expected behavior we'd like to see from compiler, totally eliminating the
possiblity of <code>read()</code>'ing a file that hasn't been opened or <code>seek()</code>'ing a file that has
already been closed:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">read_file</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">path</span><span style="color:#c0c5ce;">: &amp;Path) -&gt; String {
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> file = File::open(path);
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// opening the file _could_ fail, so we now use &quot;?&quot; to catch the exception.
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">file.</span><span style="color:#96b5b4;">open</span><span style="color:#c0c5ce;">()?;
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// if opening the file failed, then we never reach this line.
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> data = file.</span><span style="color:#96b5b4;">read</span><span style="color:#c0c5ce;">()?;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">file.</span><span style="color:#96b5b4;">close</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// ERROR! Which is now caught by the compiler.
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">file.</span><span style="color:#96b5b4;">seek</span><span style="color:#c0c5ce;">(Seek::Start);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">data
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>The error we'd see when <code>seek()</code>'ing the file would look something like:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">r[</span><span style="color:#d08770;">E0382</span><span style="color:#c0c5ce;">]: </span><span style="color:#b48ead;">use</span><span style="color:#c0c5ce;"> of moved value: `file`
</span><span style="color:#c0c5ce;"> </span><span style="color:#c0c5ce;">--&gt; src/main.rs:</span><span style="color:#d08770;">9</span><span style="color:#c0c5ce;">:</span><span style="color:#d08770;">14
</span><span style="color:#c0c5ce;">     </span><span style="color:#c0c5ce;">|
</span><span style="color:#c0c5ce;">   </span><span style="color:#d08770;">8 </span><span style="color:#c0c5ce;">|     file.</span><span style="color:#96b5b4;">close</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">     </span><span style="color:#c0c5ce;">|          - value moved here
</span><span style="color:#c0c5ce;">   </span><span style="color:#d08770;">9 </span><span style="color:#c0c5ce;">|     file.</span><span style="color:#96b5b4;">seek</span><span style="color:#c0c5ce;">(Seek::Start);
</span><span style="color:#c0c5ce;">     </span><span style="color:#c0c5ce;">|        ^ value used here after move
</span><span style="color:#c0c5ce;">     </span><span style="color:#c0c5ce;">|
</span><span style="color:#c0c5ce;">     </span><span style="color:#c0c5ce;">= note: </span><span style="color:#b48ead;">move</span><span style="color:#c0c5ce;"> occurs because `file` has </span><span style="color:#b48ead;">type</span><span style="color:#c0c5ce;"> `File`, which does not implement the `Copy` </span><span style="color:#b48ead;">trait
</span></pre>
<p>This is Rust's ownership-centric view of the world at work. Since <code>File</code> is a type
that doesn't implement <code>Copy</code> it is an <em><em>affline type</em></em> where:</p>
<blockquote>
<p>Affine types are a version of linear types allowing to discard (i.e. not use) a resource, corresponding to affine logic. An affine resource <em>can only be used once</em>, while a linear one must be used once.</p>
</blockquote>
<p>And thus, by passing the <code>File</code> resource by value, we have effectively <em>moved</em> it, or <em>transferred ownership</em> of that resource
to the <code>close()</code> method. As a perhaps trivial way of using this unique (and yet pragmatic) type system to enforce type states,
it's possible to ensure that no <code>File</code> is ever acted on after it's been closed.</p>
<p>Let's finally move into a more complex example involving the the hardware target</p>
<p>The GPIO subsystem of the Raspberry Pi is documented on page 89 (section 6) of the
<a href="https://web.stanford.edu/class/cs140e/docs/BCM2837-ARM-Peripherals.pdf">BCM2837 ARM Peripherals Manual</a></p>
<h2 id="shout-outs">Shout outs</h2>
<p>Thanks to those who wrote the Rust <a href="https://hoverbear.org/2016/10/12/rust-state-machine-pattern/">embedded book</a> on peripherals as FSMs, hoverbear's
<a href="https://hoverbear.org/2016/10/12/rust-state-machine-pattern/">&quot;Pretty State Machine Patterns in Rust&quot;</a> post, to mozilla
researcher <a href="https://yoric.github.io/post/rust-typestate/">Dale Teller</a> and their article on this subject, to the instructors who build
this <a href="https://web.stanford.edu/class/cs140e">class</a> which introduced me to many interesting subjects, and of course to the original
<a href="http://www.cs.cmu.edu/%7Ealdrich/papers/classic/tse12-typestate.pdf">paper</a> on the typestate by Robert E. Strom and Shaula Yemini. I didn't understand typestates
and their use until reading all of these resources. Affline type systems have never been so fascinating!</p>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">1</sup>
<p>Example adapted from https://en.wikipedia.org/wiki/Type_theory</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">2</sup>
<p>From <a href="https://en.wikipedia.org/wiki/Typestate_analysis">wikipedia</a>, &quot;For each two type states <code>t1 &lt; t2</code>, a unique <em>typestate coercion operation</em>
needs to be provided which, when applied to a typestate <code>t2</code>, reduces it to a typestate of <code>t1</code>...&quot;</p>
</div>

    </div>

    
        <footer>
            <hr>
            <p>
                
                
                
            </p>
        </footer>
    
</article>


    </body>

</html>
